from __future__ import division
import numpy as np
import random
import time
from definitions_numpy import *
from qutip import Qobj, identity, tensor


start = time.time()

# List of 8D Gell-Mann matrix
Gell_Mann_np_array8 = Gell_Mann(4)
for x in range(len(Gell_Mann_np_array8)):
	Gell_Mann_np_array8[x] = tensor(identity(2), Gell_Mann_np_array8[x]).full()

# List for errors
E_np_list = []
for k in range(0, 3):
	E_np_list.append(E_np(k, 1/1024))


stepsize = [1/1024, -1/1024]
best = 0


phi_best = [3.7628157972019007, 2.5890172283097694, 2.2768608311738294, 1.7755793159962843, 2.047268861986662, 0.9037052795405287, 0.7967336976882087, 1.0560554217064115, -0.36529116617952784, -0.3503301359136366, -0.007639056011541356, 1.806038835740357, 2.498050396865478, 1.219779927476257, 0.6441615234683677, 3.7084988884967265, 2.58323974986131, 1.7515007141528631, 2.1275731046357893, 2.0336885961032363, 3.2337577668974524, 1.9210442471827343, 1.114565894312593, 2.0969898074710467, 0.2526423621126904, 1.2397034798475253, 0.5993017151499396, 2.692864513920969, 3.0466701440538535, 0.8670110046194267, 2.0293077443634413, 0.08867992705319128, -1.2275105377039268, 1.4353386884452337, -0.8384396517572459, -0.14489924115405128, 3.540690846772457]
Cos_best = [-0.7990550344307653, -0.7804590593010744, 0.9224466083321737, -0.99186724308893714, 0.04572104596533319, 0.77651951202603731, -0.67130837178426495, -0.1044412817843917, 0.8741926996131838, 0.88837210639823938, -0.9726554167196418, 0.71994284600197311, 0.8374997219261231, -0.99999603132630832, 0.5854915191187425, 0.35127258105478304, -0.9710682237949123, 0.8363864007926338, -0.8833399549809868, -0.9994827247946706, -0.5276055979843891, 0.1712323127999944, -0.19578741546952053, -0.10400598954056355, -0.95188288223928363, -0.9384362546056485, 0.3736259663334138, -0.8765459353531766, 0.69300055972258356]
Sin_best = [0.60125789138343, 0.62520689116074368, 0.38612466222253833, 0.12727675391504625, 0.99895424617738915, 0.63009320536159164, 0.74117816344814091, 0.994531054647985, 0.48557916341520851, 0.45912416683676677, 0.23225296623711794, 0.69403335545964873, 0.54643775105099257, 0.0028173270369312707, 0.8106785312563958, 0.9362732367205158, 0.23880222933589662, 0.5481403000775839, 0.4687328918842673, -0.0321602679873909, 0.8494894543050756, 0.9852306811367401, 0.98064636232627989, 0.99457667082014756, 0.30646203435308939, 0.3454524512023652, 0.9275794506571514, 0.48131821409107794, 0.72093704595074448]

for x in range(len(phi_best)):
	phi_best[x] = random.uniform(0, np.pi)
for x in range(len(Cos_best)):
	y = random.uniform(0, np.pi)
	Cos_best[x] = np.cos(y)
	Sin_best[x] = np.sin(y)


# Cos_best = [-0.79905503443076531, -0.65023957206056326, 0.92244660833217373, -0.98740622109522069, 0.030107439910243561, 0.6089594484346853, -0.77846878262227681, -0.28799463945809467, 0.98113949008116519, 0.86588272555169121, -0.97265541671964184, 0.6277971887892152, 0.64101230603512616, -0.76100055148812773, 0.094096815895996944, 0.015179373066224704, -0.94444902984029488, 0.83638640079263382, -0.88333995498098683, -0.99569400081421122, -0.50080577409677496, 0.71531887529875748, -0.31652164066994004, -0.041682338557488055, -0.79291146285276282, -0.9384362546056485, 0.90565206725744996, -0.98747967218471411, 0.8414806018211165]	
# Sin_best = [0.60125789138343, 0.75972922737413195, 0.38612466222253833, 0.15820541881508418, 0.99954666827619965, 0.79320135537083136, 0.62768332340646926, 0.95763202099940348, 0.19330106311986794, 0.50024704456015989, 0.23225296623711794, 0.77837695864430523, 0.76753060102612825, 0.6487512317019255, 0.99556305136251155, 0.99988478667960357, 0.32865792251781456, 0.54814030007758385, 0.46873289188426731, 0.092700899362354927, 0.8655596898142438, 0.69879818734833643, 0.94858528925321695, 0.99913091367066553, 0.60933686256182773, 0.34545245120236517, 0.424021618637903, 0.15774630589008884, 0.54028732796427092]
# phi_best = [1.7628157972019005, 1.3858922283097697, 2.1362358311738294, 0.6974543159962843, 1.422268861986662, 0.9974552795405287, 0.5154836976882088, 1.1810554217064115, 0.7597088338204722, 0.08716986408636342, 1.0548609439884586, 1.806038835740357, 2.435550396865478, 1.219779927476257, 0.05041152346836785, 2.9116238884967265, 2.59886474986131, 1.7515007141528631, 2.2525731046357893, 1.7211885961032363, 2.6087577668974524, 1.1710442471827343, 1.317690894312593, 2.1282398074710467, 0.09639236211269042, 0.9428284798475254, 1.0993017151499396, 2.692864513920969, 2.7185451440538535, 0.8670110046194267, 2.0918077443634413, 1.0886799270531913, 0.03811446229607317, 1.3728386884452337, 0.7865603482427541, 0.3238507588459487, 2.665690846772457]


# phi_best = phi	
# Cos_best = Cos
# Sin_best = Sin



# loop several times to find maximum p0
for y in range(100):
	
	prev_best = best
	phi = list(phi_best)	
	Cos = list(Cos_best)
	Sin = list(Sin_best)


	# stepsize eiher posiive or negative
	for x in range(2):
		step = stepsize[x]	

		# loop through all variables to find biggest increase
		for n in range(len(phi) + len(Cos)):
			phi_check = list(phi)
			Cos_check = list(Cos)
			Sin_check = list(Sin)

			# first through phases
			if n < len(phi):
				
				phi_check[n] = phi_check[n] + step
				# if phi_check[n] > np.pi:
				# 	phi_check[n] = phi_check[n] - np.pi
			
			# then through angles
			else:
				
				i = n - len(phi)
				new = np.arccos(Cos_check[i]) + step
				Cos_check[i] = np.cos(new)
				Sin_check[i] = np.sin(new)

			# Make U
			# Make U
			U = np.array(U_(Cos_check, Sin_check, phi_check))
			U_dag = np.conj(U.transpose())

			# Create list E'_k
			E_U_k = []
			for k in range(0, 3):
				E_U_k.append(np.dot(U_dag, np.dot(E_np_list[k], U)))



			####################################################################################
			#############          Calculations for p_0         ################################

			# calculate p0
			p_0 = p0(U, E_U_k, Gell_Mann_np_array8)
			
			# print np.real(p_0)

			# find best
			if np.real(p_0) > best:
				# if n < len(phi):
				# 	# print phi_best[n], phi_check[n]
				# else:
					# i = n - len(phi)
					# print Cos_best[i], Cos_check[i]
					# print Sin_best[i], Sin_check[i]
				best = np.real(p_0)
				phi_best = list(phi_check)
				Cos_best = list(Cos_check)
				Sin_best = list(Sin_check)

	print step, best

	if prev_best == best:
		if stepsize[0] < 1/(2**20):
			break
		else:
			stepsize[0] = stepsize[0] / 2
			stepsize[1] = stepsize[1] / 2



end = time.time()

print best
print phi_best
print Cos_best
print Sin_best


print end - start




